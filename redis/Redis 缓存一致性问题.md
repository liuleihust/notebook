## 如何保证缓存与数据库的双写一致性

> 只要用缓存，就会涉及到缓存与数据库**双存储双写**，你只要是双写，就一定会有数据一致性问题，你如何解决一致性问题？

###什么情况下会出现缓存与数据的不一致性问题

高并发场景存在非常多的缓存DB等数据一致性问题，这些问题主要是这样产生的：

高并发系统，系统的压力一般都在后端 的DB中。大量的并发写、并发读，给DB 带来非常大的压力。不一小心就会产生**崩溃**，导致整个系统不可用。

为了降低 DB 的压力，我们通常会引起缓存来解决问题。Redis 做了一个缓冲操作，让请求先访问到 redis ，而不是直接访问 Mysql 等数据库。

![](C:\Users\Administrator\Documents\笔记\img\sys-cache-redis-db-2018.png)

但是加了缓存后，就会出现数据一致性问题 ，以及**缓存设计不合理，缓存穿透**等问题。

> **缓存雪崩**：请求过多，导致缓存机器意外发生宕机。全部请求叨叨数据库，也会产生数据库挂掉。
>
> **缓存穿透**：访问请求，缓存中没有，全部到达数据库。（一般为恶意请求，故意请求缓存中不存在的数据）。
>
> **缓存击穿**：某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个key 在失效的瞬间，大量请求就击穿了缓存，直接请求数据库，就像在一道屏障上凿开一个洞。
>
> 

数据库和缓存更新，就容易出现 缓存和数据库间的数据一致性问题。

- 如果说删除了缓存 Redis ，还没来得及写库Mysql ，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，**此时缓存中为脏数据**。
- 如果写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。因为写和读是并发的，没法保证顺序，就会出现缓存和数据库的数据不一致的问题。

用一张图来说明缓存和数据库一致性问题！

![](C:\Users\Administrator\Documents\笔记\img\cache-db-cap-consistency.png)

### 解决方法

解决方法主要有四种：

#### Cache Aside Pattern(缓存旁路模式)

缓存旁路模式就是 **先更新数据库，再删缓存** 。

> **更新缓存还是删除缓存的    问题**？
>
> - 复杂情况下，缓存中的数据不是简单的从数据库中取出，还需要进行一多表查询，计算等才能得到值。
> - **懒加载思想**：使用时，在修改缓存，如果每次修改数据库都重新计算，生成缓存，那么就会频繁更新缓存。

这种策略的方式：

- **失效**：应用程序从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
- **命中**：应用程序从 cache 中去数据，取到后返回。
- **更新**：先把数据存到数据库中，成功后，再让缓存失效。

`Facebook` 就是采用这种策略,但是这种情况一般会出现几种问题：

1. **原子性问题**  更新数据成功，删除缓存失败。
2. **并发问题**  ：比如两个线程，请求A 去做查询操作，请求B 做更新操作。那么就会产生，请求 A去查缓存时，缓存刚好失效，请求B 将新值写入数据库中，并删除缓存，然后请求A 将从数据库查到的旧值写入缓存中。（这种情况很少发生，因为要 满足缓存失效和同时又个写线程，而且写操作会锁表，所以想读到脏数据，读操作必须在写操作之前进入数据库，因为写操作耗时长，缓存中添加了脏数据后还会被删除）



总结： 这种方式 会出现原子性问题，一般不会出现并发问题。

可以采取 删除 缓存失败的时候 重新删除缓存，直到成功。

操作步骤：

1. 更新数据库数据
2. 缓存因为种种问题删除失败
3. 将需要删除的key发送至消息队列
4. 自己消费消息，获得需要删除的key
5. 继续重试删除操作，直到成功。



**先删除缓存，再更新数据库。** 即使原子性问题产生，但是 不会出现一致性问题。

但是会出现 **并发问题**，读写线程同时访问的时候就会出现不一致问题。

####  读写操作串行化

强一致性实现

***对同一个数据的操作串行化***

更新数据的时候，根据**数据的唯一标识**，将操作路由之后，发送到一个JVM 内部队列中。读取数据时，如果发现数据不再缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送到同一个JVM 内部队列。

一个队列对应一个工作线程，每个工作线程 **串行** 拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

这里有一个**优化点**，一个队列中，其实**多个更新缓存请求串在一起是没意义的**，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。

待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。

如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从**数据库**中读取当前的旧值。

高并发的场景，该解决方案要注意的问题：

- 读请求长时阻塞

该解决方案最大的风险点在于说，可能数据更新很频繁，导致队列中中挤压了大量更新操作在里面，然后读请求会发生大量的超时，最终导致大量的请求直接走数据库。
# 虚拟机测试程序



`标志寄存器`

1. 运算结果标志位

进位标志CF ，主要用来反映运算是否产生进位或错位。如果运算结果的最高位产生一个进位或借位，那么，其值为1 ，否则为0

2. 状态控制标志位

状态控制标志位是用来控制cpu 操作的，它们要通过专门的指令才能使之发生改变。

**追踪标志TF(Trap Flag)**
当追踪标志TF 被置为1 时，CPU 进入单步执行方式，即每执行一条指令，产生一个单步中断请求。这 种方式主要用于程序的调试。 

指令系统中没有专门的指令来改变标志位TF 的值，但程序员可用其它办法来改变其值。 

**中断允许标志IF(Interrupt-enable Flag)**
中断允许标志IF 是用来决定CPU 是否响应CPU 外部的可屏蔽中断发 出的中断请求。但不管该标志为何值，CPU 都必须响应CPU 外部的不可屏蔽中断所发出的中断请求，以及CPU 内部产生的中断请求。具体规定如下： 

(1) 、当IF=1 时，CPU 可以响应CPU 外部的可屏蔽中断发出的中断请求； 

(2) 、当IF=0 时，CPU 不响应CPU 外部的可屏蔽中断发出的中断请求。 

CPU 的指令系统中也有专门的指令来改变标志位IF 的值。 

**方向标志DF(Direction Flag)**
方向标志DF 用来决定在串操作指令执行时有关指针寄存器发生调整的方向。具体规定在第 5.2.11 节—— 字符串操作指令—— 中给出。在微机的指令系统中，还提供了专门的指令来改变标志位DF 的值。 

## Makefile

> Makefile 是一个非常聪明的批处理文件
>
> 我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：
>
> ​          1.如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。
>
> ​      2.如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。
>
> ​      3.如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。
>
> 只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。

Makefile 的规则 ：

`target..:prerequisites..`

`command`

 **target**也就是一个目标文件，可以是**Object File**，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。

​    **prerequisites**就是，要生成那个target所需要的文件或是目标。

​    **command**也就是make需要执行的命令。（任意的Shell命令）

例如

`ipl.bin : ipl.nas Makefile` : 如果想制作文件 ipl.bin ，就先检查一下*ipl.nas* 和*Makefile* 这两个文件是否都准备好了。

如果这两个文件都有了，Make工具就会自动执行Makefile 的下一行。

如果所需的文件不存在，它也会自动去查找所需文件的生成方法。

`make -r `： 取消隐含规则，make 会预先设定好一些规则，进行隐式的推导。







## FAT12

主磁盘结构：

1. **引导扇区**

位于第一个扇区，在软盘上就是0柱面0 磁头1 扇区

2. **文件分配表**

紧接着引导扇区的是两个完全相同的FAT表，每个FAT表占用9个扇区

3. **根目录区**

FAT 表之后就是根目录区，根目录区长度不固定

4. **数据区**

根目录后面就是数据区



### 引导扇区格式

`ORG`

其作用是告诉汇编程序，再开始执行的时候，将某段机器语言装载到内存中的哪个地址。如果没有它，有些指令就不能正确地翻译和执行。由于这条指令不是机器语言中的直接指令，所以被称为伪指令。

##### 内存分布图

*0x00007c00-0x00007dff ：启动区内容的装载地址*

`JNC`

dos/bios 对文件、磁盘、IO的检测都是通过CF 为来确定是否操作成功的，cf=0表示成功，cf=1 失败并返回错误值。错误号码放在AH内。

`ES寄存器`

在16 位，它是一个段寄存器，[ES:BX] 代表 ES*16+BX 的内存地址。

**0x7c00～0x7dff用于启动区，0x7e00以后直到0x9fbff为止的区域都没有特别的用途，操作系统 可以随便使用。**

读取10 个柱面 18 个扇区 读取到 0x0820 地址上，这个程序已经用从软盘读取的数据填满了内存0x08200～ 0x34fff的地方。 

将这个程序保存到磁盘映像中，将磁盘映像文件写入磁盘中，在windows 里打开那个磁盘，把操作系统保存到磁盘上。

一般想空软盘保存文件时，文件名会写在 0x002600 以后的地方。文件的内容会写在 0x004200以后的地方。

所以操作系统的 ORG 0XC200 。

### 操作系统

`ORG 0XC200`

根据 FAT 文件格式，引导程序 读取10个柱面18 个扇区到内存中，操作系统的程序处于 0XC200 。

`asmhead.nas`： 进行操作系统启动阶段的一系列设置



#### bios 中断服务

bios 中断简单的说就是你机器上的BIOS 提供的中断，在BIOS 中断的后面，实际上是一些对端口的输入输出操作，pc 的每个端口都实现特点的功能，我们完全可以不调用BIOS 提供的中断而直接用输入输出指令对这写端口进行操作，从而实现像调用BIOS中断一样的功能，但是前提是你必须对这些端口有详细的了解。反过来说，pc的中断系统的一大好处就是能够让程序员无需了解系统底层的硬件知识的而能够编程，bios 中断服务为我们封装了许多系统底层的细节。

#### 敏感指令

`HLT`



改指令使 8086 进入暂停状态，在暂停状态CPU不进行任何操作，该指令也不影响任何标志。 

当8086/8088处于暂停状态时，只有以下3种情况之一发生时才能脱离暂停状态：
①RESET线上有[复位信号](https://www.baidu.com/s?wd=复位信号&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)；
②在NMI（非屏蔽中断请求）线上有请求；
③在中断允许情形下（IF=1），在INTR（可屏蔽的外部中断请求）线上有请求。
HALT指令可以这样理解，在8088/8086系统中CPU启动后，处理器的指令指针寄存器IP会根据指令长度（顺序执行指令）、指令性质（转移指令、子程序调用指令）在[系统时钟](https://www.baidu.com/s?wd=系统时钟&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)驱动下自动做出调整，使程序按指定流向执行，也就是每执行一条指令，IP都或自动增减其值。当执行到HALT指令时，IP在硬件上被冻结，程序暂定，直到上面说的三种脱离暂停状态情况之一出现。

>可屏蔽中断与不可屏蔽中断的区别：
>
>cpu 一般设置两根中断请求输入线： 可屏蔽中断请求INTR和NMI。可屏蔽中断，除了受本身的屏蔽位的控制外，还要受到一个总的控制，即cpu 标志寄存器中的中断允许标志位IF的控制，IF位为1，可以得到CPU的响应，否则，得不到响应。
>
>对于软中断，它不受IF位的影响，所以属于非屏蔽中断范畴。

#### 分页机制

**分段机制**： 逻辑地址转换成线性地址

**分页机制**： 线性地址转换成物理地址

分页机制可和分段机制保护措施合用或替代分段机制的保护措施。

##### 分页机制的启用

设置控制寄存器 `CR0`的PG 可以启用分页机制。如果PG=1 。则启用分页操作，**处理器会使用分页机制将线性地址转换成物理地址**。如果PG=0，则禁用分页机制，**此时分段机制产生的线性地址直接用作物理地址**。

x86 使用4K 字节固定大小的页面，每个页面均是4KB，该分页机制将2^32字节的线性地址分成2^20 个页面。分页机制通过把线性地址空间中的页面重新定位到物理地址空间进行操作。由于4K大小的页面作为一个单元进行映射，并且对其于4K边界，因此线性地址的低12位可做为页内偏移量直接作为物理地址的低12 位。



分页机制与分段机制的不同：

分页与分段的最大的不同之处在于分页使用了固定长度 的页面。段的长度通常与存放在其中的代码或数据结构有相同的长度。与段不同，页面有固定的长度。如果仅使用分段地址转换，那么存储在物理内存中的一个数据结构将包含其所有的部分。如果使用了分页，那么一个数据结构就可以一部分存储于物理内存中，而另一部分保存在磁盘中。




> QEMU提供一系列的硬件模拟设备(CPU，网卡，磁盘等)，客户机指令都需要QEMU翻译，因而性能较差。**KVM是linux内核提供的虚拟化，可以用来进行vCPU的创建与运行，虚拟内存的地址空间分配，指令执行效率较高，但缺少IO设备的虚拟化**。QEMU-KVM就是KVM与QEMU的结合，KVM负责CPU虚拟化+内存虚拟化，QEMU模拟其它IO设备。



### 虚拟化-软件方案

纯软件虚拟化，顾名思义，就是用纯软件的方法在现有的物理平台上，实现对物理平台访问的**截获和模拟**。

- **QEMU** ，它是通过纯软件来**仿真**X86平台处理器的取指、解码和执行，客户机的指令并不在物理平台上直接执行。由于所有的指令都是软件模拟的，因此性能往往比较差，但是可以在同一平台上模拟不同架构平台的虚拟机。
- VMWare 的软件虚拟化则使用了动态二进制翻译的技术。虚拟机监控机在可控制的范围内，允许客户机的指令在物理平台上直接运行。但是，客户机指令在运行前会被虚拟机监控机扫描，其中突破虚拟机监控机限制的指令会被动态替换为可以在物理平台上直接运行的安全指令，或替换为对虚拟机监控器的软件调用。这样做的好处是比纯软件模拟性能有大幅的提升，但是也同时失去了跨平台虚拟化的能力。

### 虚拟化-硬件方案

硬件虚拟化，就是物理平台本身提供了对特殊指令的截获和重定向的硬件支持。甚至，新的硬件会提供额外的资源来帮助软件实现对关键硬件资源的虚拟化，从而提升性能。

支持虚拟技术的X86 CPU 带有特别优化过额度指令集来控制虚拟过程，通过这些指令集，VMM 会很容易将客户机置与一种受限制的模式下运行，一旦客户机试图访问物理资源，硬件会暂停客户机的运行，将控制权交给VMM 处理。VMM 还可以利用硬件的虚拟化增强机制，将客户机在受限模式下对一些特定资源的访问，完全由硬件重定向到VMM 指定的虚拟资源，整个过程不需要暂停客户机的运行和VMM 软件的参与。

## KVM 简介

> Kernel Virtual Machine (内核虚拟机)，通过加载新的模块从而使Linux Kernel  本身变成一个 Hypervisor ，2006 年 KVM 源代码被正式接纳进入了 Linux Kernel 。 

### KVM 功能概览

KVM 是基于虚拟化扩展的（Intel VT 或AMD-V） 的 X86硬件，是Linux 完全原生的全虚拟化支持。

在KVM 架构中，虚拟机实现为从常规的Linux 进程，**由标准Linux 调度程序进行调度**。事实上，每个虚拟机CPU 显示为一个常规的Linux进程。这使KVM 能够享受Linux 内核的所有功能。

KVM 本身不执行任何模拟，需要用户空间程序通过 /dev/kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供 模拟的I/O ，并将它的视频显示映射回宿主的显示屏。



### KVM 架构

![1564046892939](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1564046892939.png)

KVM 通过内核模块的形式实现出来就好，其他的部分则尽可能充分利用Linux 内核的既有实现，最大限度地重用代码。

## KVM 模块

KVM 模块是KVM 虚拟机的核心部分。其主要功能是初始化CPU硬件，打开虚拟机模式，然后将虚拟客户机运行在虚拟机模式下，并对虚拟客户机地运行提供一定的支持。

以KVM 在Intel 公司的CPU 上运行为例，在被内核加载的时候，KVM 模块会先初始化内部的数据结构；做好准备后，**KVM**模块会检测系统当前的CPU，然后打开CPU控制寄存器CR4中的虚拟化模式开关，并通过执行VMXON 指令将宿主操作系统置于虚拟化模式的根模式；最后，KVM模块创建特殊设备文件 **/dev/kvm** 并等待来自用户空间的命令。接下来虚拟机的创建和运行是一个用户空间的应用程序（qemu）和KVM 模块相互配合的过程。

KVM 模块与用户空间QEMU 的通信接口主要是一系列针对特殊设备文件的IOCTL 调用。IOCTL 调用就是 “**创建虚拟机**”。在这里，创建虚拟机可以理解成KVM 为某个特定的虚拟客户机创建对应的**内核数据结构**。同时，KVM 还会返回一个文件句柄来代表所创建的**虚拟机**。针对该文件句柄的IOCTL 调用可以对虚拟机做相应的管理，比如创建用户空间虚拟地址和客户机物理地址及真实内存物理地址的映射关系，再比如创建多个可供运行的虚拟处理器（vcpu）。KVM 模块会为每个创建出来的虚拟处理器生成对应的文件句柄，对虚拟处理器相应的文件句柄进行响应的**IOCTL** 调用，就可以对虚拟处理器进行管理。

用户空间准备好的虚拟机再KVM 模块的支持下，被置于虚拟化模式中的非根模式下，开始执行二进制指令。**再非根模式下，所有敏感的二进制指令都会被处理器捕捉到，处理器再保存现场之后自动切换到 根模式，由KVM决定如何进一步处理。**

#### 内存虚拟化

虚拟机模式下，处理器中内存管理单元（MMU） 则必须再一次查询的时候完成两次地址转换。这是因为，除了要将客户机程序的虚拟地址转换成为客户机物理地址以外，还必须将客户机物理地址转化成为真实物理地址。KVM 模块开始使用了**影子页表**的技术来解决这个问题：客户机运行时候，处理器真正使用的页表并不是客户机操作系统维护的页表，而是KVM 模块根据这个页表维护的另外一套**影子页表**。

影子页表开销大，新的处理器再硬件上做了增强，硬件可以自动进行两级转换生成正确的内存访问地址。**KVM 模块将其称为二维分页机制**。

处理器对设备的访问主要是通过IO 指令和MMIO ，其中IO 指令会被处理器直接截获，MMIO 会通过配置内存虚拟化来捕捉。一般来说，只有对性能要求较高的虚拟设备才会由KVM内核模块来直接负责，比如虚拟中断控制器和虚拟时钟，这样可以减少处理器的模式切换的开销。



## QEMU

再虚拟机运行期间，QEMU 会通过KVM 模块提供的系统调用进入内核，由KVM 模块负责虚拟机置于处理器的特殊模式运行。**遇到虚拟机进行输入输出操作，KVM 模块会从上次的系统调用出口返回QEMU** ，由QEMU 来负责解析和模拟这些设备。
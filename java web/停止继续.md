

每次调用 `TestController#config()` ，会初始化，脚本执行状态`runingState==run`

。

`TestController#controllMsg`  设置 `xml` #`runingState`。

点击继续->  `TestController#getres(continue)`  ->`TestController#controllMsg(continue)`  。

```java

/*
TestController.java
*/

...
    
 /* 
    先获取当前 runingState ，如果之前 
    暂停 == pause
    执行 == run
    初始 == init ?? 这个 按理说 不存在这个状态
    停止 == stop 
 */
String runInfo = xmlMap.get(user).getRuningState();

switch (zl) {
            case "pause":
                if (runInfo.equals("run")) {

                    t = worker.pause();
                    //这里只是对引擎进行了暂停  暂停会导致controller中正在执行的getres中已经生成的消息return的过程中出现错误，
                    //需要对暂停的时机进行控制，如果有消息正在confirm的过程，则应该等待结束在暂停
                    //还需要对controller中进行处理：
                    //对getres函数也应该进行暂停，
                    if (t) {
                        xmlMap.get(user).setRuningState("pause");
                        state = "success";
                    } else {
                        state = "fail";
                    }
                } else {
                    state = "error";
                }
                break;
            case "continue":
        		// 对于 continue ,如果此时状态为 stop，则state = error
                if (runInfo.equals("pause")) {
                    t = worker.restart();
                    if (t) {
                        xmlMap.get(user).setRuningState("run");
                        state = "success";
                    } else {
                        state = "fail";
                    }
                } else {
                    state = "error";
                }
                //System.out.println("continue state" + state);
//                getres("start", request);
                break;
            case "stop":
                if (runInfo.equals("pause") || runInfo.equals("run")) {
                    t = worker.stop();
                    if (t) {
                        xmlMap.get(user).setRuningState("stop");
                        state = "success";
                    } else {
                        state = "fail";
                    }
                } else {
                    state = "error";
                }
                break;
            default:
                state = "error";
        }


// 最后函数返回  continue#error 
```



点击继续 --> 返回 `res== continue#error`

  

`z1= continue` `zlsate=error` `conten= 错误`

 进入 

```java
case"continue":
	$.messager.alert("提示", "继续执行");
    tabWIndow.consoleScrollShow2("start");
    break;
```



进入`TestController#getres(start)` 。 

```java
else{
    // 因为 之前 stop,所以现在 state = stop
    String state = xmlMap.get(user).getRuningState();
}

// ..

// 直接返回 stop#success
else if (state.equals("stop")) {
                return MyUtil.getJsonFromObject("stop" + "#" + "success");
```

结果返回 前端 `thread.js`  。 弹出  `停止成功` 。 



### 停止后执行不成功

 点击 `执行 ` 。调用 前端 `dycontent.js#getSelected()`



其中有个 异步函数 `ajax `，它配置了一个参数`async: false` 。 表明 这个方法执行是同步的。

`ajax` 请求 `TestController@getRunstate`

```java
// 取得 当前 运行状态，此处为 stop
state = xmlMap.get(user).getRuningState();

// 返回 stop
return MyUtil.getJsonFromObject(state);

```

结果返回 到前端 `dycontent.js#getSelected()` 中，

```java
            switch (res) {
                case "run":
                case "init":
                case "halfpause":
                    $.messager.alert("警告", "已有脚本正在执行，请等待执行完成！");
                    runState = false;
                    break;
                case "pause":
                    $.messager.alert("警告", "执行已经暂停，请点击继续按钮，继续执行脚本！");
                    runState = false;
                    break;
                case "null":
                case "finish":
                    runState = true;
                    break;
                default:
                    runState = false;
            }
```

只有当前运行 状态为 `null` `finish` 时 才会继续执行。



###  刷新后能够继续执行

退出登录，刷新，关闭浏览器，退出登录时需清除`session`

会调用 `TestController#destroyExecute`  

```java
该函数会调用

clearAllMap(user);

// clearAllMap 会调用
xmlMap.remove(user); 

下次点击执行时，就会执行了。
```

### 2019/6/12 修改代码

#### 测试报告

1. 添加 测试环境

- 更新了` dbtestweb_v2.5_0611\src\main\resources\template\report.ftl`  文件
- `dbtestweb_v2.5_0611\src\main\java\com\xq\controller\ReportController.java` 文件中 387 行

![1560344842970](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1560344842970.png)

在 `SerCmdEx` 中添加了 获得 硬件配置的函数。

在`TestController` 177 行处 添加 root 用户的 `ip` 和` passwd` 。

- `E:\dbtestweb_v2.5_0611\src\main\webapp\dbtestweb\js\downloadReport.js`  13 行 更新了 提示语句。



#### 控制台输出信息

`E:\dbtestweb_v2.5_0611\src\main\java\com\wen\OSXmlProcess.java` 添加了 

`showfail` 函数

修改了 `showSuccess` 函数

在 3155 行 出 增加了 连接错误的输出语句。

495 行处 添加 执行错误的输出。



### 半自动化 控制台输出内容重复

"halfpause#success#0.5.3.1.1.2.2.1.#2#执行脚本： 测试不可伪造鉴别\n</br>测试通过\n</br>测试通过...</br>执行脚本： 测试不可伪造鉴别\n</br>测试通过\n</br>测试通过...</br>#1.不可伪造鉴别##{\"type\":\"提示信息\",\"allch\":[\"YES\",\"NO\"],\"allMsg\":[\"以下操作在被测操作系统上进行：\\n1：用户进入系统登录界面，输入用户名和口令信息\\n2：用户选中输入的口令信息，进行复制（使用组合键ctrl+c）\\n3：用户删除已输入的口令信息，进行粘贴（使用组合键ctrl+v）\\n4：观察口令是否可被粘贴到输入框中，预期粘贴失败\\n5：清除测试环境\",\"manual\"]}"

`Z1` = halfpause

`Id` = 0.5.3.1.1.2.2.1.

`msgstate` =2

`res` = 

`ctrlmap`  = `ConcurrentMap<String, Map<String, Vector<Message>>>`

里面存放着  某个用户的 所有 临时消息队列。

Map<String, Vector<Message>> 对应着该用户 每个脚本的 结果
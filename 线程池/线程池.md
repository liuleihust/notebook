### ThreadGroup

> 为线程服务，用户通过使用线程组的概念批量管理线程，如批量停止或挂起等。 每个线程创建时，都会纳入线程组的树形结构 

#### ThreadGroup 的使用场景

1. 一个大型任务，可分成多个独立的子线程并发进行，最后等待所有的子线程执行结束然后继续往下执行

```java
			int activeCount = tgroup.activeCount();
                while ( activeCount > 0 ) {
                    System.out.println("activeCount=" + activeCount );
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    activeCount = tgroup.activeCount();
                }
```

当 acctiveCount =0 时，代表执行结束。

2.一个大型任务，可分成多个独立的子线程并发进行，只要其中的某个子线程完成了任务条件，就算任务完成，则调用 threadGroup.interrupt() 方法 其他的子线程就可以停止了



![](http://47.101.139.24/upload/2019/4/2018101216242678620190519162428122.png)

#### 树形结构的代码实现

##### 1.根节点唯一性

```java
/*
ThreadGroup.java
*/

static final ThreadGroup systemThreadGroup = new ThreadGroup();
```

使用静态变量，确保全局只有一个对象 

##### 2.添加线程节点Thread

需要先计算出它的父线程组，然后把它加入父线程组。每个父线程组维护一个数组Threads[]，来保存它的子线程。 计算父线程组有两种方式

1.  指定父线程组 

```java
/*
Thread.java
*/
public Thread(ThreadGroup group, Runnable target) {
    init(group, target, "Thread-" + nextThreadNum(), 0);
}
```

2.使用缺省父线程组 parent.getThreadGroup() 

```java
/*
Thread.java
*/
ublic Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
}

private void init(ThreadGroup g, Runnable target, String name, long stackSize) {
    Thread parent = currentThread();
    if (g == null) {
        g = parent.getThreadGroup();
    }
    //新线程继承父线程组的优先级
    this.target = target;
    this.priority = parent.getPriority();
    this.daemon = parent.isDaemon();
     ...
}

```

在线程启动的时候，会将该线程加入到线程组中。

```java
/*
Thread.java
*/
public synchronized void start() {
      
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        group.add(this);
        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }
```

```java
/*
ThreadGroup.java
*/


Thread threads[];

void add(Thread t) {
	//自动扩展
	if (threads == null) {
	     threads = new Thread[4];
	 } else if (nthreads == threads.length) {
	     threads = Arrays.copyOf(threads, nthreads * 2);
	 }
	 //添加节点到threads[]
	 threads[nthreads] = t;
	 ...
 }
```

threads[]数组实现了自动扩展，因为它无法确定子线程节点有多少。 threads[]的初始长度是4，如果满了，就以2倍速度扩展，8，16，… 

##### 3. 添加线程组节点ThreadGroup

需要计算其父线程组节点，然后父线程组纳入此节点。每个父线程组通过维护groups[]，来保存它的子线程组节点。 

```java
/*
ThreadGroup.java
*/
ThreadGroup groups[];

private final void add(ThreadGroup g){

	//实现groups数组的自动扩展
	if (groups == null) {
	    groups = new ThreadGroup[4];
	} else if (ngroups == groups.length) {
	    groups = Arrays.copyOf(groups, ngroups * 2);
	}
	
	//添加节点到groups[]
	groups[ngroups] = g;
}

```

##### 4. 移除子线程节点或子线程组节点

子线程节点和子线程组节点的移除操作一致，不同的是操作的列表不同，子线程节点操作的是threads[],而子线程组节点操作的是groups[]。这里只以子线程节点为例。 

```java
/*
ThreadGroup.java
*/
private void remove(Thread t) {
        synchronized (this) {
            if (destroyed) {
                return;
            }
            for (int i = 0 ; i < nthreads ; i++) {
                if (threads[i] == t) {
                    System.arraycopy(threads, i + 1, threads, i, --nthreads - i);
                    // Zap dangling reference to the dead thread so that
                    // the garbage collector will collect it.
                    threads[nthreads] = null;
                    break;
                }
            }
        }
    }


```

###  TreadFactory  线程所需要的工厂

```java
public class DefaultThreadFactory implements ThreadFactory {

    private static final AtomicInteger GROUP_COUNTER = new AtomicInteger(1);
    private static final ThreadGroup group = new ThreadGroup("MyThreadPool-" + GROUP_COUNTER.getAndDecrement());
    private static final AtomicInteger COUNTER = new AtomicInteger(0);
	
    // 创建线程， 拥有自己的 线程组，定义自己的线程名字
    @Override
    public Thread createThread(Runnable runnable) {
        return new Thread(group, runnable, "thread-pool-" + COUNTER.getAndDecrement());
    }
}
```

### RunnableQueue 任务队列

> 任务队列主要用于存放提交到线程池中的任务

```java
//任务队列，主要用于缓存提交到线程池中的任务
public interface RunnableQueue {

    //当有新的任务进来时首先会offer到队列中
    void offer(Runnable runnable);

    //通过线程通过take方法获取Runnable
    Runnable take();

    //获取任务队列中任务的数量
    int size();
}
```

实现方式 可以为 `LinkedRunnableQueue`

```java
// 主要成员变量，用于存放 任务
private final LinkedList<Runnable> runnableList = new LinkedList<>();
```

添加任务

```java
    @Override
    public void offer(Runnable runnable) {
        synchronized (runnableList) {
            if (runnableList.size() >= limit) {
                //无法容纳新的任务时执行拒绝策略,拒绝策略一般会抛出异常，或者会立即执行，可以选择不同的拒绝策略
                denyPolicy.reject(runnable, threadPool);
            } else {
                //将任务加入到队尾，并且唤醒阻塞中的线程
                runnableList.addLast(runnable);
                runnableList.notifyAll();
            }
        }

    }
```

取出任务

```java
    @Override
    public Runnable take() {
        synchronized (runnableList) {
            while (runnableList.isEmpty()) {
                try {
                    //如果任务队列中没有可执行的任务，则当前线程将会挂起，进入runnableList关联的moniter waitset中等待唤醒（新的任务加入）
                    runnableList.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //从任务头部移除一个任务
            return runnableList.removeFirst();
        }
    }
```

### ThreadPool

成员变量

```java
   //初始化线程数量
    private final int initSize;

    //线程池最大线程数量
    private final int maxSize;

    //线程池核心线程数量
    private final int coreSize;

    //当前活跃的线程数量
    private int activeCount;
```

初始化方法

```java
    private void init() {
        // 因为 ThreadPool 继承了 Thread，调用 Thread.start()  ,执行自己定义的 run() 方法
        start();

        for (int i = 0; i < initSize; i++) {//初始化线程个数
              // 初始化一个线程
            	newThread();
        }
    }

//  start() 方法会调用 Thread.run() 
public void run() {
        //run方法继承自Thread，主要用于维护线程数量，比如扩容、回收等工作
        while (!isShutdown && !isInterrupted()) {
            try {
                timeUnit.sleep(keepAliveTime);
            } catch (InterruptedException e) {
                e.printStackTrace();
                isShutdown = true;
                break;
            }
            synchronized (this) {
                if (isShutdown) {
                    break;
                }
                //当前的队列中有任务尚未处理，并且activeCount<coreSize则继续扩容
                if (runnableQueue.size() > 0 && activeCount < coreSize) {
                    for (int i = coreSize; i < maxSize; i++) {
                        //  创建新的工作线程
                        newThread();
                    }
                }
                //如果任务队列中没有任务，则需要回收，回收至coreSize即可
                if (runnableQueue.size() == 0 && activeCount > coreSize) {
                    for (int i = coreSize; i < activeCount; i++) {
                        removeThread();
                    }

                }
            }
        }
    }
    

	//线程池自动维护
    private void newThread() {
        //创建任务线程，并且启动 
        /*
         InternalTask  是Runnable的一个实现，用于线程池内部，该类会使用到 RunableQueue ，然后不断从队列中取出某个Runnable 并允许其 run 方法。故InternalTask 每次的 run 方法 内容都不一样。
        */
        InternalTask internalTask = new InternalTask(runnableQueue);
        // 创建一个新的线程
        Thread thread = this.threadFactory.createThread(internalTask);
        // ThreadTask 是 InternalTask 和 Thread的一个组合
        ThreadTask threadTask = new ThreadTask(thread, internalTask);
        // 添加 threadTask 到 工作线程队列。
        threadQueue.offer(threadTask);
        this.activeCount++;
        // 开启 线程
        thread.start();
    }

   private void removeThread() {
        //从线程池中移除某个线程
        ThreadTask threadTask = threadQueue.remove();
        // 将 internalTask 状态标记为 false
        threadTask.internalTask.stop();
        this.activeCount--;
    }
```

提交任务

```java
    @Override
    public void execute(Runnable runnable) {
        if (this.isShutdown()) {
            throw new IllegalStateException("The thread pool is destory");
        }
        //提交任务只是简单地往任务队列中插入Runnable
        this.runnableQueue.offer(runnable);

    }
```

##### InternalTask

> 线程池中一个线程能够不停的执行任务队列中任务的原因就是因为： 线程池中有自己定义的一个InternalTask ，它是对 Runnable的一个实现。

它的run 方法为

```java
    @Override
    public void run() {
        //如果当前任务为running并且没有中断，则其将不断地从queue中获取runnable，然后执行其run方法
        while (running && !Thread.currentThread().isInterrupted()) {
            Runnable task = runnableQueue.take();
            task.run();
        }
    }
```

### Executor框架

> 在Java中通过Executor框架提供线程池支持，通过该框架我们可以创建出如下几类线程池：

Executor

#### 1、newSingleThreadExecutor

是单个工作线程的Executor，它的`corePoolSize``和maximumPoolSize`被设置为1。采用的是无界队列`LinkedBlockingQueue`作为线程池的工作队列（队列的容量为`Interger.MAX_VALUE`）。由于使用了无界队列，如果请求过多会导致`OOM`，在并发请求量比较大的系统中，使用此线程池需要注意。

```java
public class SingleThreadExecutorDemo {

    public static void main(String args[]) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        for (int i = 0; i <= 20; i++) {
            pool.execute(() -> System.out.println(Thread.currentThread().getName() + "[running done]"));
        }
    }
}
```

#### 2.newFixedThreadPool

被称为可重用固定线程数线程池。与SingleThreadExecutor一样它也使用了**无界队列**作为工作队列，如果没有执行方法shutdown()的话也是不会拒绝任务的。

```java
public class FixThreadPoolDemo {
    public static void main(String args[]) {
        ExecutorService pool = Executors.newFixedThreadPool(10);
        for (int i = 0; i <= 100; i++) {
            pool.execute(() -> {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + "[runing done]");
            });
        }
    }
}
```

####  3、newCachedThreadPool

是一个会根据需要创建新线程的线程池。它的`corePoolSize`被设置为0，即`corePool`为空；`maximumPoolSize`被设置为`Integer.MAX_VALUE`,即`maximumPool`是无界的，正因为如此，如果主线程提交任务的速度高于线程池中线程处理任务的速度的话，线程池就会不断创建新的线程，极端情况下就可能导致线程创建过多而耗尽CPU和内存资源。

```java


public class CacheThreadPoolDemo {
public static void main(String args[]) {
ExecutorService pool = Executors.newCachedThreadPool();
for (int i = 0; i <= 20; i++) {
pool.execute(() -> {
System.out.println(Thread.currentThread().getName() + "[runing done]");
});
}
}
}
```

#### 4. newScheduledThreadPool

用于实现多个线程的周期性任务，它会把待调度的任务放到延迟队列`DelayQueue`中。与`CacheThreadPool`一样，它允许创建的最大线程数也是`Interger.MAX_VALUE`。

```java
public class ScheduledThreadPoolExecutorDemo {
    public static void main(String args[]) {
        ScheduledExecutorService pool = Executors.newScheduledThreadPool(10);
        for (int i = 0; i <= 20; i++) {
            pool.schedule(() -> {
                System.out.println(Thread.currentThread().getName() + "[runing done]");
            }, 10, TimeUnit.SECONDS);
        }
    }
```

以上逻辑实现的是：延迟10秒后开始执行任务。

**ScheduledExecutorService** 的使用

> ScheduledExecutorService的主要作用就是可以将定时任务与线程池功能结合使用。

1. ### 使用scheduleAtFixedRate()方法实现周期性执行

```java
public class ScheduledExecutorServiceTest {
    public static void main(String[] args) {
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println("run "+ System.currentTimeMillis());
            }
        }, 0, 100, TimeUnit.MILLISECONDS);
    }
}
```

运行结果如下：立刻执行，而且每隔100ms 执行一次

```java
run 1501051231331
run 1501051231427
run 1501051231527
run 1501051231628
run 1501051231726
run 1501051231827
run 1501051231926
run 1501051232026
run 1501051232127
.......
```

2. ### ScheduledExecutorService使用Callable延迟运行

```java
package com.linux.thread;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class CallableRun {
    public static void main(String[] args) {
        try {
            List<Callable> callableList = new ArrayList<>();
            callableList.add(new MyCallableA());
            callableList.add(new MyCallableB());
            ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
            // 延迟4 秒后开始运行
            ScheduledFuture futureA = executorService.schedule(callableList.get(0), 4L, TimeUnit.SECONDS);
            ScheduledFuture futureB = executorService.schedule(callableList.get(1), 4L, TimeUnit.SECONDS);

            System.out.println("            X = " + System.currentTimeMillis());
            // 阻塞等待线程返回结果
            System.out.println("返回值A：" + futureA.get());
            System.out.println("返回值B：" + futureB.get());
            System.out.println("            Y = " + System.currentTimeMillis());

            executorService.shutdown();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }

    static class MyCallableA implements Callable<String> {
        @Override
        public String call() throws Exception{
            try {
                System.out.println("callA begin " + Thread.currentThread().getName() + ", " + System.currentTimeMillis());
                TimeUnit.SECONDS.sleep(3); // 休眠3秒
                System.out.println("callA end " + Thread.currentThread().getName() + ", " + System.currentTimeMillis());
            } catch (Exception e) {
                e.printStackTrace();
            }
            return "returnA";
        }
    }

    static class MyCallableB implements Callable<String>  {
        @Override
        public String call() throws Exception{
            System.out.println("callB begin " + Thread.currentThread().getName() + ", " + System.currentTimeMillis());
            System.out.println("callB end " + Thread.currentThread().getName() + ", " + System.currentTimeMillis());
            return "returnB";
        }
    }
}
```

运行结果：

```java
            X = 1558319747294
 // 延迟4 秒 开始执行任务
callA begin pool-1-thread-1, 1558319751296
// 线程睡了3s
callA end pool-1-thread-1, 1558319754296
返回值A：returnA
callB begin pool-1-thread-1, 1558319754296
callB end pool-1-thread-1, 1558319754296
返回值B：returnB
            Y = 1558319754296
```

3. ### 使用scheduleWithFixedDelay()方法实现周期性执行

```java
package com.linux.thread;

import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class RunMain {
    public static void main(String[] args) {
        ScheduledExecutorService executorService = Executors.newSingleThreadScheduledExecutor();
        System.out.println("          x = " + System.currentTimeMillis());
        // 延迟 1s 开始，2s执行一次任务
        executorService.scheduleWithFixedDelay(new MyRunable(), 1, 2, TimeUnit.SECONDS);
        System.out.println("          y = " + System.currentTimeMillis());
    }

    static class MyRunable implements Runnable {
        @Override
        public void run() {
            try {
                System.out.println("     begin = " + System.currentTimeMillis() + ", name: " + Thread.currentThread().getName());
                TimeUnit.SECONDS.sleep(4);
                System.out.println("     end = " + System.currentTimeMillis() + ", name: " + Thread.currentThread().getName());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## Callable

　先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：

```java
public interface Runnable {
    public abstract void run();
}
```

由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。

Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：

```java
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。

那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：

```java
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```

第一个submit方法里面的参数类型就是Callable。

暂时只需要知道Callable一般是和**ExecutorService**配合来使用的，具体的使用方法讲在后面讲述。

一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。

## Future

Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。

`Future`类位于`java.util.concurrent`包下，它是一个接口：

```java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

在Future接口中声明了5个方法，下面依次解释每个方法的作用：

- `cancel`方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。
- `isCancelled`方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。
- `isDone`方法表示任务是否已经完成，若任务完成，则返回true；
- `get()`方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；
- `get(long timeout, TimeUnit unit)`用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。

　　也就是说Future提供了三种功能：

　　1）判断任务是否完成；

　　2）能够中断任务；

　　3）能够获取任务执行结果。

　　因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。

## FutureTask

我们先来看一下FutureTask的实现

```java
public class FutureTask<V> implements RunnableFuture<V>
```

FutureTask类实现了`RunnableFuture`接口，我们看一下`RunnableFuture`接口的实现：

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    void run();
}   
```

`FutureTask` 中run方法的实现

```java
    public void run() {
        if (state != NEW ||
            !RUNNER.compareAndSet(this, null, Thread.currentThread()))
            return;
        try {
            Callable<V> c = callable;
            if (c != null && state == NEW) {
                V result;
                boolean ran;
                try {
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s >= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
```

`run()` 方法即允许`Callable` 中的 `call`  方法。并将 `FutureTask` 中的属性`outcome`设置为

`result`。

可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，**又可以作为Future得到Callable的返回值**。

FutureTask提供了2个构造器：

```java
public FutureTask(Callable<V> callable) {
}
public FutureTask(Runnable runnable, V result) {
}
```
构造函数就是设置`FutureTask`  中的相关属性。
## 如何实现

看下 线程池`AbstractExecutorService` 中`sumbit（Callable<T> task）` 的实现

```java
public <T> Future<T> submit(Callable<T> task) {
        if (task == null) throw new NullPointerException();
        RunnableFuture<T> ftask = newTaskFor(task);
        execute(ftask);
        return ftask;
    }
```

其中：

- `RunnableFuture` 继承了 Runnable接口和Future接口，`newTaskFor` 将`Callable` 封装成`RunnableFuture<T>`。

  ```java
      protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
          return new FutureTask<T>(callable);
      }
  ```

- `execute` 执行 `ftask` 中的 `run` 方法，`run` 方法会执行 `call` 方法，并加结果赋值给`ftask` 。

**总的来说，执行线程与主线程都 享有同一个 `FutureTask` 对象。**

## 关闭线程池

### 立即关闭

```java
    
	/**
     * 立即关闭线程池，会造成任务丢失
     */
    
public void shutDownNow(){
     isShutDown.set(true);
     tryClose(false);
}

/*
关闭线程池
@param isTry true 尝试关闭 -- > 会等待所有任务执行完毕
			 false 立即关闭线程池  --> 任务有丢失的可能
			 
*/
public void tryclose(boolean isTry){
    if(!isTry){
        closeAllTask();
    }else{
        if(isShutDown.get() && totalTask.get() == 0){
            closeAllTask();
        }
    }
}

/**
	关闭所有任务
**/

private void closeAllTask(){
    for(Worker worker:workers){
        worker.close();
    }
}

public void close(){
    thread.interrupt(); // 改变线程运行状态
}

```

很容易看出，最终就是遍历线程池里所有的 `worker` 线程挨个执行他们的中断函数。

### 完事后关闭

```java
    
public void shutDown(){
     isShutDown.set(true);
     tryClose(true);
}
```

这个时候，所有任务执行完毕后才回去停止。


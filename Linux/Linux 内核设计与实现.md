#Linux 内核设计与实现



### 第一章 Linux 内核简介

#### 1.1 unix 的历史

Unix 是贝尔实验室的产品。由于Unix 系统设计简洁并且在发布时提供源代码，所以许多其他组织和团体都对它进行了进一步的开发。**加州伯克利**便是其中影响最大的一个。它们推出的变体叫做***BSD***（伯克利软件版本） 

由于最初一流的设计和以后多年的创新与逐步提高，Unix系统成为一个强大、健壮和稳定的操作系统。下面的几个特点是使Unix强大的根本原理。

1.  简洁 ，没有过多的系统调用且设计目的明确。
2.  所有东西都被当做文件对待，通过一套相同的系统调用接口 
3.  C语言编写，硬件移植能力强 
4.  进程创建迅速，独特的fork()系统调用 
5.  简单而稳定的进程间通信元语 

快速简洁的进程创建过程使Unix的程序把目标放在**一次执行保质保量地完成一个任务上**。简单稳定的进程间通信机制又可以保证这些单一目的的简单程序可以方便地组合在一起，去解决现实中变得越来越复杂的任务。

#### 1.2 Linux 简介

与Unix 的关系： 

二者的关系，不是大哥和小弟，"UNIX 是 Linux 的父亲"这个说法更怡当。 

二者也有两个大的区别：

1. UNIX 系统大多是与硬件配套的，也就是说，**大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，**而 Linux 则可以运行在多种硬件平台上；
2. UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码的。

**Linux 的组成**：LInux 内核和其他一些应用程序组成不同的 distribution。

Linux 内核是自由软件，它使用**GNU**（革奴计划）的GPL作为限制条款。你可以自由地获取内核代码并随意修改它，但如果你希望发布你修改过的内核，你也得保证让得到你的内核的人同时享有你曾经享受过的所有权利。

Linux 用途广泛，包含的东西也名目繁多。Linux系统的基础是内核、C库、工具集和系统的基本攻击。



#### 1.3 操作系统和内核简介

操作系统：指系统中负责完成最基本功能和系统管理的部分。包括：**内核、设备驱动程序、启动引导程序、命令行shell或其他种类的用户界面、基本的文件管理和系统工具**。

内核组成：**中断服务程序、进程调度程序、内存管理程序、网络/进程间通信等**。内核独立于应用程序，它一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，统称为内核空间。

应用程序通过系统调用与内核通信。


##### 单内核与微内核设计之比较

单内核就是把它从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。内核可以直接调用函数，这与用户空间应用程序没有什么区别，单模块具有简单和性能高的特点。大多数Unix系统都设计为单模块。

微内核的功能被划分为多个独立的过程，只有强烈请求特权服务的进程才运行在各自的地址空间上。因此，就不可能像单模块内核那样直接调用函数，而是通过**消息传递**处理微内核通信：系统采用了IPC机制，进程间各自独立有效地避免了一个服务器的失效祸及另一个。



Linux 是一个单内核，不过Linux 是模块化的。                   

#### 1.4 Linux 内核和传统unix 内核比较

1. linux 支持动态加载内核模块
2. linux支持对称多处理机制（SMP）
3. linux内核可抢占
4. linux对线程的支持：**内核不区分线程与其他一般的进程**。对于内核来说，所有的进程都一样，只不过是其中的一些共享资源而已。
5. linux提供设备类的面向对象设备模式、热插拔，以及用户空间的设备文件系统（sysfs）

#### 1.5 Linux 内核版本

**2.6.26.1** 

主版本号是2，从版本号是6，修订版本号是30，稳定版本号是1.

从版本号是偶数，那么此内核就是稳定版，如果是奇数，那么它就是开发版。



### 第二章 从内核出发

####  2.4 内核开发特点

内核编程不能访问C库也不能访问标准C的头文件
内核编程必须使用GNU C
缺乏用户空间的内存保护机制
难以执行浮点运算
每个进程只有很小的定长堆栈
内核支持异步中断、抢占、SMP，必须时刻注意同步和并发
头文件
基本的头文件：include目录(#include <linux/inotify.h>)
体系结构相关：arch/<architecture>/include/asm目录(#include <asm/ioctl.h>)

GNU C
Linux 上可用的 C 编译器是 GNU C 编译器。 GNU C 对标准 C 进行一系列扩展，以增强标准 C 的功能。不符合ANSI C标准，内核开发者总是要用到gcc的拓展部分。内核开发使用的C语言涵盖ISO C99和GNU C扩展特性。

**内联函数**： 对时间要求高，而本身长度较短的函数定义为内联
static inline void wolf(unsigned long tail_size)
需要使用static作为关键字、inline进行限定;内联函数必须在使用前就定义好，否则无法展开（static inline的内联函数，一般情况下不会产生函数本身的代码，而是全部被嵌入在被调用的地方。如果不加static，则表示该函数有可能会被其他编译单元所调用，所以一定会产生函数本身的代码。所以加了static，一般可令可执行文件变小。内核里一般见不到只用inline的情况，而都是使用static inline。）
**内联汇编**： asm()嵌入汇编在代码
**分支声明**： likely()和unlikely()，內建指令优化
**没有内存保护机制**： 内核错误导致oops，内核中的内存都不分页
**容积小而固定的栈**： 8K或16K
**同步和并发**: 自旋锁和信号量

### 第三章 进程管理

#### 3.1进程

- **进程**：处理执行期的程序以及相关的资源的总称。（可执行程序代码、打开的文件、挂起的信号、内核内部数据、处理器状态、内存地址空间、执行线程、数据段）

- **线程**: 进程中活动的对象，内核最小的调度对象。（**独立的程序计数器**、**进程栈**、**进程寄存器**）

- **linux线程实现非常特别**：不区分线程和进程，线程只不过是一种特殊的进程罢了。
  进程的两种虚拟机制：虚拟处理器和虚拟内存。

- **fork()**: 系统调用，通过复制一个现有进程来创建一个新的进程。

- **exec()**：fork()新创建的进程都是为了立即执行新的程序，可以利用exec()函数创建新的地址空间，将新的程序载入。

- **exit()**：系统调用退出执行，会将其占用的资源释放掉，父进程可以通过wait()系统调用查询子进程是否终结，进程退出执行后被设置为僵尸状态，直到它的父进程调用wait()或waitpid()。

- **wait()/ waitpid()**：父进程可以通过wait4()系统调用查询子进程是否终结，这使得进程拥有等待特定进程执行完毕的能力。
  (ps: https://blog.csdn.net/oqqhutu12345678/article/details/75043726

- **wait工作原理**：
  (1). 子进程结束时，系统向其父进程发送SIGCHILD信号；(2). 父进程调用wait函数后阻塞；(3). 父进程被SIGCHILD信号唤醒，然后去回收僵尸子进程；(4). 父子进程之间是异步的，SIGCHILD信号机制就是为了解决父子进程之间的异步通信问题；(5). 若父进程没有任何子进程则wait返回错误。
  **waitpid和wait的区别**：
  (1). waitpid可以回收特定PID的子进程；(2). waitpid可以以阻塞和非阻塞式两种工作模式

  

#### 3.2 进程描述符和任务结构

  

内核把进程的列表(task_struct)存放在**任务队列(task list)** 的双向循环链表中 。

**task_struct**： 进程描述符的结构，进程描述符中包含一个具体进程的**所有信息**。

  

**分配进程描述符**：

1. Linux 通过**slab分配器**分配**task_struct**结构. 达到对象复用和缓存着色的目的（预分配和重复使用task_struct,避免动态分配和释放开销）
   (2). struct thread_info：由于slab分配器动态生成task_struct,所以只需要在栈底(对于向下增长的栈)或栈顶(对于向上增长的栈)创建一个新的结构struct thread_info，总之，在内核栈的最最最底部(看图). 在<asm/thread_info.h>中定义

**进程描述符的获取**

-  内核通过唯一的进程标识值PID来识别每个进程。最大值32769（<linux/threads.h>可修改，或通过/proc/sys/kernel/pid_max提高上限）
-  task_struct的获取。由于内核访问任务需要获取指向其task_struct的指针。因此，current宏查找到当前正在运行进程的task_struct的速度很重要。

>- 拿**专门寄存器**指向当前task_struct
>- x86，在内核栈尾部**通过thread_info，计算偏移间接查找task_struct**。

**进程状态**

(1). TASK_RUNNING（运行）：进程可执行的；或正在执行，或在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态。（可执行和正在执行都是这个状态）
(2). TASK_INTERRUPTIBLE（可中断）：**进程正在睡眠**，等待某些条件的达成，此状态进程可接收信号而被提前唤醒并准备投入运行
(3). task_unniterruptible（不可中断的）：同上，但接收到信号也不会被唤醒
(4). __task_traced：被其他进程跟踪的进程，如ptrace对调试进程进行跟踪。
(5). __task_stopped（停止）
-1 unrunnable, 0 runnable, >0 stopped

**进程上下文**

> 可执行程序代码是进程的重要组成部分。进程上下文实际上是进程执行活动全过程的静态描述。我们把已执行过的进程指令和数据在寄存器与堆栈中的内容称为上文吗，把正在执行的指令和数据在寄存器和堆栈中的内容称为正文，把待执行的指令和数据在寄存器与堆栈中的内容称为下文。具体来说，进程上下文包括计算机系统中与执行该进程相关的各种寄存器的值。

 一般程序在用户空间执行，当程序执行**系统调用**或**触发异常**，它就陷入内核空间，此时，内核"**代表进程执行**”并处于进程上下文。

**进程家族树**

在Linux系统中，所有的进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的**初始化脚本**（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。

每个task_struct都包含一个指向其父进程task_struct、叫做parent的指针，还包含一个称为children 的子进程链表。

#### 3.3 进程创建

> 许多其他的操作系统产生进程的机制是：
>
> **在新的地址空间里创建进程，读入可执行文件，最后开始执行。**

Unix将上述步骤分解到两个单独的函数中去执行：**fork()** 和 **exec()**

1. **fork()** 拷贝当前进程创建一个子进程，子进程和父进程的区别仅仅在于PID、PPID和某些资源的统计量（例如，挂起的信号，它没有必要被继承）。
2. **exec()** 函数负责读取可执行文件并将其载入地址空间开始运行。

**写时拷贝**

Linux 的 fork()使用写时拷贝页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一拷贝。

只有在需要写入的时候，数据才会被复制。在此之前，只是以只读方式共享。在页根本不会被写入的情况下，它们就无需复制。

fork() 的实际开销就**是复制父进程的页表以及给子进程创建唯一的进程描述符。**

**fork()**

linux通过clone()系统调用实现fork()，这个调用通过一系列参数指明父子进程需要共享的资源，fork()、vfork()、__clone()库函数根据各自需要的参数标志调用clone：fork()/vfork()/__clone() ⇒ clone() ⇒ do_fork()

do_fork()完成创建中的大部分工作，定义在kernel/fork.c中，该函数调用copy_process()函数：
(1). 调用dup_task_struct()：为新进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。
(2). 检查并确保当前用户拥有的进程数没超出资源限制
(3). 子进程开始与父进程分离。task_struct中许多成员清零或初始化
(4). 子进程状态设为TASK_UNINTERRUPTIBLE，保证不会投入运行
(5). 调用copy_flags()以更新task_struct的flags成员。表明进程还未调用exec()的PF_FORKNOEXEC标志被设置。
(6). alloc_pid()分配新的PID
(7). **根据clone()参数标志，拷贝或共享打开文件、文件系统信息、信号处理函数、进程地址空间、命名空间等**
(8). 扫尾工作，返回一个指向子进程的指针。
do_fork()完成copy_process()后唤醒新创建的子进程，**内核有意选择子进程首先执行， 因为子进程一般都会马上调用exec()函数，如果父进程首先执行的话，有可能会开始向地址空间写入，造成写时拷贝的额外开销**。

**vfork()**

不拷贝父进程的页表，除此之外与 fork()相同。子进程作为父进程的一个单独线程在它的地址空间中运行，**父进程被阻塞**，直到子进程退出或执行exec(), 子进程不能向地址空间写入。 

#### 3.4 线程在Linux 中的实现

 **linux把所有线程当做进程来实现（轻量级进程）**，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程拥有唯一的task_struct，对linux来说，是一种进程间共享资源的手段。 

1. 创建线程

线程的创建与普通进程的创建类似，不过在调用clone()的时候需要传递一些参数。
`clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0);`
表明父子共享地址空间、文件系统资源、文件描述符和信号处理程序
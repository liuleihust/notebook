## 堆外内存

>  堆外内存是相对于堆内内存的一个概念。堆内内存是由JVM所管控的java进程内存，我们平时在java 中 创建的对象都处于堆内内存中，并且它们遵循JVM 的内存管理机制，**JVM 会采用垃圾回收机制统一管理它们的内存**。那么堆外内存就是存在于JVM管控之外的一块内存区域，因此它是不受JVM的管控。

堆外内存是通过 `unsafe.allocateMemory(size)`;是个一个`native`方法，这个方法分配的是堆外内存，通过C的`malloc`来进行分配的。分配的内存是系统本地的内存，并不在Java的内存中，也不属于JVM管控范围。

### 为什么需要堆外内存

在进行IO 操作时 需要 通过 **系统调用** 调用内核态中的资源，即 内存中的数据 与 硬盘 网卡等资源 传输，而操作系统 不能直接访问 `java` 堆内的 内存区域。 这是因为如果操作系统 正在访问 这个内存地址的时候，java在这个时候进行了 `GC` 操作，而`GC` 操作会涉及到数据的移动操作。数据的移动会使得 系统调用 的数据错乱。所以JNI 调用的内存是不能进行`GC`操作的。



为了解决 操作系统无法直接操作堆内内存，所以需要将 堆内内存与堆外内存之间数据拷贝（**并且在将堆内内存拷贝到堆外内存的过程JVM会保证不会进行GC操作**）：比如我们要完成一个从文件中读数据到堆内内存的操作，即FileChannelImpl.read(HeapByteBuffer)。这里实际上File I/O会将数据读到堆外内存中，然后 堆外内存再将 数据拷贝到堆内内存，这样我们就读到了文件中的内存。

```java
    static int read(FileDescriptor var0, ByteBuffer var1, long var2, NativeDispatcher var4) throws IOException {
        if (var1.isReadOnly()) {
            throw new IllegalArgumentException("Read-only buffer");
        } else if (var1 instanceof DirectBuffer) {
            return readIntoNativeBuffer(var0, var1, var2, var4);
        } else {
            // 分配临时的  堆外内存
            ByteBuffer var5 = Util.getTemporaryDirectBuffer(var1.remaining());

            int var7;
            try {
                // File I/O 操作会将数据读入到堆外内存中
                int var6 = readIntoNativeBuffer(var0, var5, var2, var4);
                var5.flip();
                if (var6 > 0) {
                    // 将堆外内存的数据拷贝到 堆内内存 中
                    var1.put(var5);
                }

                var7 = var6;
            } finally {
                // 里面会调用DirectBuffer.cleaner().clean()来 释放临时的堆外内存
                Util.offerFirstTemporaryDirectBuffer(var5);
            }
            return var7;
        }
    }
```

而写操作则反之，我们会将堆内内存的数据线写到对堆外内存中，然后操作系统会将堆外内存的数据写入到文件中。

或者直接使用堆外内存，如`DirectByteBuffer` ：这种方式是直接在堆外分配一个内存(即，native memory)来存储数据，程序通过JNI直接将数据读/写到堆外内存中。**因为数据直接写入到了堆外内存中，所以这种方式就不会再在JVM管控的堆内再分配内存来存储数据了**，也就不存在堆内内存和堆外内存数据拷贝的操作了。这样在进行I/O操作时，**只需要将这个堆外内存地址传给JNI的I/O的函数就好了**。

## 虚引用

> 虚引用是使用`PhantomReference`创建的引用，虚引用也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个。一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用获得一个对象实例。

如果一个对象与GC Roots之间仅存在虚引用，则称这个对象为`虚可达（phantom reachable）`对象。

当试图通过虚引用的get()方法取得强引用时，总是会返回null，并且，**虚引用必须和引用队列** 一起使用。既然这么虚，那么它出现的意义何在？？

它的作用在于跟踪垃圾回收过程，在对象被收集器回收时收到一个系统通知。 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，将这个虚引用加入引用队列，在其关联的虚引用出队前，不会**彻底销毁该对象**。 所以可以通过检查引用队列中是否有相应的虚引用来判断对象是否已经被回收了。

如果一个对象没有强引用和软引用，对于垃圾回收器而言便是可以被清除的，在清除之前，会调用其`finalize`方法，如果一个对象已经被调用过finalize方法但是还没有被释放，它就变成了一个虚可达对象。

与软引用和弱引用不同，显式使用虚引用可以阻止对象被清除，只有在程序中显式或者隐式移除这个虚引用时，这个已经执行过finalize方法的对象才会被清除。想要显式的移除虚引用的话，只需要将其从引用队列中取出然后扔掉（置为null）即可。

> 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队 列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

### finalize 方法

(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，**由一低优先级线程执行该队列中对象的finalize方法**。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。

(2) 具体的finalize流程：

对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：·

- unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的
- finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行
- finalized: 表示GC已经对该对象执行过finalize方法
- reachable: 表示GC Roots引用可达
- finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达
- unreachable：对象不可通过上面两种途径可达

## 堆外内存的释放

netty 中调用 `ByteBuf` 的 `release（）`方法。

来到`AbstractReferenceCountedByteBuf`的`release`方法，最终都会调用到它的`release0()`方法： 

当`refCnt-decrement` 为0的时候，也就是当前的引用数和需要减去的引用数相同，那么就是调用

`deallocate()`方法释放内存了,进入了deallocate()方法。





`Cleaner`是`PhantomReference`的子类，并通过自身的`next`和`prev`字段维护的一个双向链表。`PhantomReference`的作用在于跟踪垃圾回收过程，并不会对对象的垃圾回收过程造成任何的影响。
 所以`cleaner = Cleaner.create(this, new Deallocator(base, size, cap))`; 用于对当前构造的DirectByteBuffer对象的垃圾回收过程进行跟踪。

> `DirectByteBuffer`对象本身其实是很小的，但是它后面可能关联了一个非常大的堆外内存，因此我们通常称之为冰山对象。
>
> 创建 `DirectByteBuffer` 时， 将 一个**虚引用** 指向`DirectByteBuffer` ，即`Cleaner`。当`DirectByteBuffer`被jvm回收时，会将这个对象加入到 引用队列中。

 当DirectByteBuffer对象从pending状态 ——> enqueue状态时，会触发Cleaner的clean()，而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。


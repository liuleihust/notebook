## 用户登录功能分布式 session



#### 两次 MD5

1. inputPassToFormPass ( 用户输入的密码 加上 随机因子(防止利用彩虹表反查) +MD5  提交表单到后台)
2. formPassToDBPass （用户提交的密码在后台 再加上 随机因子(每个用户不一样，存在数据库中)+MD5 得到后的结果与数据库查询的密码是否一致）

登陆操作:

用户 提交 mobile + Password(经过一次MD5 )

1. 先去数据库中查询用户是否存在，如果不存在，则直接返回。
2. 获取数据库中用户的 随机因子，然后将用户上传的密码加上随机因子 通过MD5 加密后查看是否 与数据库中的密码相等。
3. 如果登陆成功，通过 UUIDUtil (**UUID保证同一时空中的所有机器都是唯一的，用到了以太网地址、纳米级时间、芯片ID码和随机数** )生成用户token 。
4. 获取到 token 后，在redis 中生成**key**(redis中的key 为了保持**唯一性**，每个key 都有个前缀，也叫作命名空间，这里为 类名+自定义的 前缀作为前缀，加上生成的唯一 UUID ) ： **value**（user 对象经过 Json 转换为 json字符串）.
5. 将这个 token 通过 response.addCookie(cookie)  添加到本地 cookie ，以后每次访问 请求中都会携带这个 cookie。
6. **拦截器**：拦截所有 请求，在 处理请求前，获取请求参数或者 cookie 中的 token，然后去 redis 查找 对应的 user,将 这个 user 放入到 请求的 **threadLocal** 对象。当 controller 中的参数需要 获取 user 时，直接从 **threadLocal** 对象中获取 **user** 。

### 商品列表

生成 商品列表，需要 获取数据库数据，但是商品列表信息不需要频繁的查询数据库。

所以在后端 渲染过一次 页面后 直接保存到 redis 中，设置 过期 时间 60s,以后每次先查询redis, 然后如果有直接返回就可以了。

### 商品详情页

需要实时从数据库中获取数据，每次查询都从数据库中查询。前后端分离，每次刷新，只传少部分数据。

也可以将每商品详情页的数据保存在 redis，减少数据库的访问。



### 秒杀商品

1. **redis 设置商品数量**，来一个请求先 将redis 中的商品减一，如果redis 商品数量小于0，则直接返回，秒杀失败，否则进行秒杀操作。这里 redis 中的商品数量与数据库中的商品数量是不一致的，因为 存在很多情况，redis 商品数量减少了，但是 数据库中没有减少。 所以可以增大  redis 中的商品数量。
2. 内存中记录 秒杀完毕标志，当数据库或redis 中商品数量变为0 时在内存中设置 秒杀结束的标志。 后面的请求 查询秒杀结束直接返回。
3. **秒杀操作**：减库存 下订单 是一个 事务操作。
4. **如何解决超卖问题与 一个用户仅能购买一个商品？** 减库存时，添加一个乐观锁，如果减完库存小于0 则进行回滚操作。在订单表 添加 userid 与 goodsid 的唯一索引，防止同一用户多次下单。
5. **异步秒杀操作**：生成秒杀 信息，加入 消息队列。前端轮询秒杀结果，查询订单表 是否有订单信息，如果有则返回 秒杀成功；查看是否秒杀结束，如果结束了则返回秒杀失败，否则 返回秒杀中。 利用 消息队列 提高用户体验。

rabbitmq 如何做到消息不重复不丢失？

将消息队列持久化（将交换机或队列的数据保存到磁盘，服务器宕机或重启之后依然存在）。

确认机制：

- **自动确认**

只要消息从队列中获取，无论消费者获取到消息后是否成功消费，都认为消息已经成功消费。

- **手动确认**

消费者从队列中获取消息后，服务器会将消息标记为不可用，直到消费者反馈。



### 

## 页面优化技术

1. 页面缓存+url缓存+对象缓存

**- 页面缓存**： 将 渲染过的 页面 加到 redis 中， 设置一个较小的 过期时间，以后直接从redis中获取页面，不需要重复渲染。

- **url缓存**: 例如 商品详情，将每个商品详情都进行缓存

**- 对象缓存**：用户信息缓存到redis 中

1. 页面静态化，前后端分离

**页面静态化的优点**：

浏览区可以吧 html 缓存到 客户端，页面数据不需要重复下载，只需要下载动态数据。

3. 静态资源优化

4. CDN 优化

#### 查询缓存

1. 查询 用户是否存在
2. 查询订单是否存在

#### 静态资源优化

1. **JS/CSS 压缩 ，减少流量**
2. **多个JS/CSS 组合，减少连接数**

CDN 就近访问

解决超卖

1. 数据库加唯一索引：防止用户重复购买
2. SQL加库存数量判断：防止库存变成负的

### 接口优化

1. Redis 预减库存减少数据库访问
2. 内存标记减少对Redis访问
3. 请求写入队缓冲，异步下单，增强用户体验
4. Nginx 水平扩展

减少数据库访问：

1. 系统初始化，把商品库存数量加载到Redis
2. 收到请求，Redis预减库存，库存不足，直接返回
3. 请求入队，立即返回排队中
4. 请求出队，生成订单，减少库存
5. 客户端轮询，是否秒杀成功



### 安全优化

1. 秒杀接口地址隐藏

思路：秒杀开始之前，先去请求接口获取秒杀地址

- 接口改造，带上 PathVariable参数

- 添加生成地址的接口

- 秒杀收到请求，先验证PathVariable



2. 数学公式验证码

思路：点击秒杀之前，先输入验证码，分散用户的请求

- 添加生成验证码的接口
- 在获取秒杀路径的时候，验证验证码
- ScriptEgine的使用

3. 接口限流防刷（key 为 请求 url +用户 id）

 思路：对接口做限流，使用拦截器，可以限制用户在一定时间内访问的次数，超过直接返回 信息。



### 限流算法

限流是解决高并发大流量的一种方案，至少是可以保证应用的可用性。

通常有以下两种限流方案：

- 漏桶算法
- 令牌桶算法

#### 漏桶算法

漏桶算法非常简单，就是将流量放入桶中并按照一定的速率流出。如果流量过大时候并不会提高流出效率，而溢出的流量也只能是抛弃掉了。

#### 令牌桶算法







